---
title: "Go编码规范"
date: 2022-01-21T15:17:21+08:00
draft: false
author: Mario
tags: [ "golang", "go", "编码编码" ]
categories:
  - "posts"
  - "golang"
---

### 指导原则

#### 指向 interface 的指针

如果希望接口方法修改底层数据，必须使用使用指针传递（将对象指针赋值给接口变量）。

#### 接收器 (receiver) 与接口

使用值接收器的方法既可以通过值调用，也可以通过指针调用。

带指针接收器的方法只能通过指针或 [addressable values](https://golang.org/ref/spec#Method_values)调用。

#### 零值 Mutex 是有效的

零值 `sync.Mutex` 和 `sync.RWMutex` 是有效的。所以指向 mutex 的指针基本是不必要的。

#### 在边界处拷贝 Slices 和 Maps

slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。

**接收 Slices 和 Maps**

请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。

**返回 slices 或 maps**

同样，请注意用户对暴露内部状态的 map 或 slice 的修改。

#### 使用 defer 释放资源

使用 defer 释放资源，诸如文件和锁。

使用defer提升代码可读性是值得的，因为使用defer的开销很小。

#### Channel 的 size 要么是 1，要么是无缓冲的

channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。

#### 枚举从 1 开始

在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。

#### 使用time处理时间

使用 `time.Time` 表达瞬时时间。

使用 `time.Duration` 表达时间段。

#### Errors

**错误类型**

使用 `errors.New` 表示带有静态字符串的错误。 如果调用者需要匹配并处理此错误，则将此错误导出为变量以支持将其与 `errors.Is` 匹配。

对于动态字符串的错误， 如果调用者不需要匹配它，则使用 `fmt.Errorf`， 如果调用者确实需要匹配它，则自定义 `error`。

**错误包装**

使用 `fmt.Errorf` 为你的错误添加上下文， 根据调用者是否应该能够匹配和提取根本原因，在 `%w` 或 `%v` 动词之间进行选择。

**错误命名**

对于存储为全局变量的错误值， 根据是否导出，使用前缀 `Err` 或 `err`。

对于自定义错误类型，请改用后缀 `Error`。

#### 不要使用 panic

在生产环境中运行的代码必须避免出现 panic。panic 是**级联失败**的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。

即使在测试代码中，也优先使用`t.Fatal`或者`t.FailNow`而不是 panic 来确保失败被标记。

#### 避免可变全局变量

使用选择依赖注入方式避免改变全局变量。 既适用于函数指针又适用于其他值类型。

#### 避免在公共结构中嵌入类型

这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。

#### 避免使用内置名称

Go [语言规范](https://golang.org/ref/spec) 概述了几个内置的， 不应在Go项目中使用的 [预先声明的标识符](https://golang.org/ref/spec#Predeclared_identifiers)。

#### 避免使用 `init()`

尽可能避免使用`init()`。

#### 追加时优先指定切片容量

在尽可能的情况下，在初始化要追加的切片时为`make()`提供一个容量值。

### 主函数退出方式(Exit)

Go程序使用[`os.Exit`](https://golang.org/pkg/os/#Exit) 或者 [`log.Fatal*`](https://golang.org/pkg/log/#Fatal) 立即退出 （使用`panic`不是退出程序的好方法）。

**仅在`main()`** 中调用其中一个 `os.Exit` 或者 `log.Fatal*`。所有其他函数应将错误返回到信号失败中。

### 性能

#### 优先使用 strconv 而不是 fmt

将原语转换为字符串或从字符串转换时，`strconv`速度比`fmt`快。

#### 避免字符串到字节的转换

不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。

#### 指定容器容量

尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。

**指定Map容量提示**

在尽可能的情况下，在使用 `make()` 初始化的时候提供容量信息。

**指定切片容量**

在尽可能的情况下，在使用`make()`初始化切片时提供容量信息，特别是在追加切片时。

### 规范

#### 避免过长的行

避免使用需要读者水平滚动或过度转动头部的代码行。

我们建议将行长度限制为 **99 characters** (99个字符). 作者应该在达到这个限制之前换行， 但这不是硬性限制。 允许代码超过此限制。

#### 一致性

一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug。

#### 相似的声明放在一组

Go 语言支持将相似的声明放在一个组内。

适用于常量、变量和类型声明。

仅将相关的声明放在一组。不要将不相关的声明放在一组。

分组使用的位置没有限制，例如：你可以在函数内部使用它们。

如果变量声明与其他变量相邻，则应将变量声明（尤其是函数内部的声明）分组在一起。对一起声明的变量执行此操作，即使它们不相关。

#### import 分组

导入应该分为两组：

- 标准库
- 其他库

#### 包名

当命名包时，请按下面规则选择一个名称：

- 全部小写。没有大写或下划线。
- 大多数使用命名导入的情况下，不需要重命名。
- 简短而简洁。请记住，在每个使用的地方都完整标识了该名称。
- 不用复数。例如`net/url`，而不是`net/urls`。
- 不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。

另请参阅 [Go 包命名规则](https://blog.golang.org/package-names) 和 [Go 包样式指南](https://rakyll.org/style-packages/)。

#### 导入别名

如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。

在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。

#### 函数分组与顺序

- 函数应按粗略的调用顺序排序。
- 同一文件中的函数应按接收者分组。

因此，导出的函数应先出现在文件中，放在`struct`, `const`, `var`定义的后面。

在定义类型之后，但在接收者的其余方法之前，可能会出现一个 `newXYZ()`/`NewXYZ()`

由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。

#### 减少嵌套

代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。

#### 不必要的 else

如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。

#### 顶层变量声明

在顶层，使用标准`var`关键字。请勿指定类型，除非它与表达式的类型不同。

如果表达式的类型与所需的类型不完全匹配，请指定类型。

#### 对于未导出的顶层常量和变量，使用_作为前缀

在未导出的顶级`vars`和`consts`， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。

例外：未导出的错误值，应以`err`开头。

基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。

#### 结构体中的嵌入

嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。

#### 使用字段名初始化结构体

初始化结构体时，应该指定字段名称。现在由 [`go vet`](https://golang.org/cmd/vet/) 强制执行。

#### 本地变量声明

如果将变量明确设置为某个值，则应使用短变量声明形式 (`:=`)。

在某些情况下，`var` 使用关键字时默认值会更清晰。例如，[声明空切片](https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices)。

#### nil 是一个有效的 slice

`nil` 是一个有效的长度为 0 的 slice，这意味着，

- 您不应明确返回长度为零的切片。应该返回`nil` 来代替。
- 要检查切片是否为空，请始终使用`len(s) == 0`。而非 `nil`。
- 零值切片（用`var`声明的切片）可立即使用，无需调用`make()`创建。
- 虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。

#### 缩小变量作用域

如果有可能，尽量缩小变量作用范围。除非它与 [减少嵌套](https://github.com/xxjwxc/uber_go_guide_cn#减少嵌套)的规则冲突。

如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。

#### 使用原始字符串字面值，避免转义

Go 支持使用 [原始字符串字面值](https://golang.org/ref/spec#raw_string_lit)，也就是 " ` " 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。

#### 初始化结构体

**使用字段名初始化结构**

初始化结构时，几乎应该始终指定字段名。目前由[`go vet`](https://golang.org/cmd/vet/)强制执行。

**省略结构中的零值字段**

初始化具有字段名的结构时，除非提供有意义的上下文，否则忽略值为零的字段。 也就是，让我们自动将这些设置为零值。

**对零值结构使用 `var`**

如果在声明中省略了结构的所有字段，请使用 `var` 声明结构。

**初始化 Struct 引用**

在初始化结构引用时，请使用`&T{}`代替`new(T)`，以使其与结构体初始化一致。

#### 初始化 Maps

对于空 map 请使用 `make(..)` 初始化， 并且 map 是通过编程方式填充的。 这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。

如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。

#### 字符串 string format

如果你在函数外声明`Printf`-style 函数的格式字符串，请将其设置为`const`常量。

这有助于`go vet`对格式字符串执行静态分析。

### 编程模式

#### 表驱动测试

当测试逻辑是重复的时候，通过 [subtests](https://blog.golang.org/subtests) 使用 table 驱动的方式编写 case 代码看上去会更简洁。

```go
tests := []struct{
  give     string
  wantHost string
  wantPort string
}{
  {
    give:     "192.0.2.0:8000",
    wantHost: "192.0.2.0",
    wantPort: "8000",
  },
  {
    give:     "192.0.2.0:http",
    wantHost: "192.0.2.0",
    wantPort: "http",
  },
}

for _, tt := range tests {
  t.Run(tt.give, func(t *testing.T) {
    host, port, err := net.SplitHostPort(tt.give)
    require.NoError(t, err)
    assert.Equal(t, tt.wantHost, host)
    assert.Equal(t, tt.wantPort, port)
  })
}
```

